---
title: es6
order: 8
type: js
---

## let和const

### let

- let所声明的变量，只在let命令所在的代码块内有效

- for循环
  - 如果使用var声明i，由于全局只有一个变量i，会导致每次循环引用的变量i都是同一个，这个仅限于循环内部有函数引用或者有延时操作，正常函数内部打印i还是ok的，例子：
  ```js
  var a = []
  for(var i = 0; i < 10; i++) {
    a[i] = function () {
      console.log(i)
    }
    console.log(i) // 0 ~ 9
  }
  a[9]() // 10
  i // 10：因为要做 i < 10 的判断，所以i肯定是10
  ```
  - 如果使用let，声明的变量仅在块级作用域内有效，每一次循环都是一个新的变量。js引擎内部会记住上一轮循环的值，初始化本轮变量i时，就是在上一轮循环的基础上进行计算
  - 特殊之处：设置循环变量的部分是一个父作用域，而循环体内部是一个单独的子作用域
  ```js
  for(let i = 0; i < 3; i++) {
    // console.log(i) i is not defined
    let i = 'mallow'
    console.log(i) // mallow
  }
  ```

- 不存在变量提升：使用var会发生变量提升的现象，值为undefined，let改变了语法行为，它所声明的对象一定要在声明后使用

- 暂时性死区：只要块级作用域内存在let或const命令，它所声明的变量就绑定了这个区域，不再受外部的影响，同上面的for循环特殊之处
```js
var tmp = 123
if (true) {
  tmp = 'abc' // ReferenceError: tmp is not defined
  let tmp
}
```

- 不允许重复声明
```js
function func(arg) {
  let arg // SyntaxError: Identifier 'arg' has already been declared
}
function func(arg) {
  {
    let arg
  }
}
```

### 块级作用域

- es5只有全局作用域和函数作用域，没有块级作用域，带来的不合理场景：
  - 内层变量可能会覆盖外层变量：变量提升导致的
  ```js
  var tmp = new Date()
  function f() {
    console.log(tmp)
    if(false) {
      var tmp = 'hello world'
    }
  }
  f()
  ```
  - 用来计数的循环变量泄漏为全局变量
  ```js
  var s = 'hello'
  for(var i = 0; i < s.length; i++) {
    console.log(s[i])
  }
  console.log(i)
  ```

- es6的块级作用域
  - let实际上为js新增了块级作用域
  - 允许块级作用域的任意嵌套
  - 内层作用域可以定义外层作用域的同名变量
  - 块级作用域的出现，实际上使得广泛应用的立即执行函数表达式（IIFE）不再必要了
  ```js
  // IIFE 写法
  (function () {
    var tmp = 'xxx'
  }())

  // 块级作用域写法
  {
    let tmp = 'xxx'
  }
  ```

### 块级作用域和函数声明

- 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句

### const

- 声明一个只读的常量，一旦声明，值就不能改变

- 作用域和let相同：只在声明所在的块级作用域内有效

- 声明的常量也不提升，同样存在暂时性死区

- 不可重复声明

#### 本质

- const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。

- 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量

- 对于复合类型的数据（数组、对象），变量指向的是内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了
  - 如果真想将对象冻结，应该使用Object.freeze方法：
  ```js
  const foo = Object.freeze({})
  // 常规模式时，下面一行不起作用
  // 严格模式时，该行会报错
  foo.prop = 123
  ```
  - 除了将对象本身冻结，对象的属性也应该被冻结，如：
  ```js
  function freeze(obj) {
    Object.freeze(obj)
    Object.keys(obj).forEach(key => {
      if(typeof obj[key] === 'object') {
        freeze(obj[key])
      }
    })
  }
  ```

### 声明对象的六种方法

- es5声明变量的方法：var、function
- es6：let、const、import、class

### 顶层对象的属性

- 在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性和全局变量是等价的

- ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定：let、const、class命令声明的全局对象，不属于顶层对象的属性。全局变量将逐步和顶层对象的属性脱钩

### global对象

- 不同环境的global对象不一样，垫片库 system.global 模拟了这个提案，可以在所有环境拿到global

## 变量的解构赋值

### 数组

```js
// before
let a = 1
let b = 2
let c = 3

// now
let [a, b, c] = [1, 2, 3]
```

#### 模式匹配

```js
let [a, [b, c]] = [1, [2, 3]]
let [ , , e] = [1, 2, 3]
let [f, , g] = [1, , 3]
let [h, ...j] = [1, 2, 3, 4] // j: [2, 3, 4]
let [x, y, ...z] = [1] // x: 1; y: undefined; z: []
```

#### 不完全解构

```js
let [x, y] = [1, 2, 3]
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4]
a // 1
b // 2
d // 4
```

#### 不可遍历结构

```js
// 报错
let [foo] = 1
let [foo] = false
let [foo] = NaN
let [foo] = undefined
let [foo] = null
let [foo] = {}
```

#### Set结构

```js
let [x, y, z] = new Set(['a', 'b', 'c'])
x // 'a'

// 只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值
function* fibs() {
  let a = 0
  let b = 1
  while (true) {
    yield a; // 这个地方必须要有分号
    [a, b] = [b, a + b];
  }
}
let [one, two, three, four, five, six] = fibs()
six // 5
```

#### 默认值

```js
let [foo = true] = []
foo // true
let [x, y = 'b'] = ['a'] // x: a; y: b
let [x, y = 'b'] = ['a', undefined] // x: a; y: b
// 只有undefined，默认值才生效
let [x = 1] = [null] // x: null

// 默认值是表达式
function f() {
  console.log('aaa')
}
let [x = f()] = [1] // 因为x能取到值，所以表达式是惰性求值的，即只有在用到的时候才会求值
```

#### 引用其他变量

> 变量必须提前声明

```js
let [x = 1, y = x] = [] // x: 1; y: 1
let [x = 1, y = x] = [2] // x: 2; y: 2
let [x = 1, y = x] = [1, 2] // x: 1; y: 2
let [x = y, y = 1] = [] // ReferenceError: y is not defined
```

### 对象

- 数组元素是按次序排列的，变量取值由它的位置决定的；而对象的属性没有次序，变量必须和属性同名，才能取到正确的值
```js
let {bar, foo, baz} = { foo: 'aaa', bar: 'bbb' }
foo // aaa
bar // bbb
baz // undefined
```

#### 变量名和属性名不一致

```js
let { foo: baz } = { foo: 'aaa', bar: 'bbb' }
baz // 'aaa'

let obj = { first: 'hello', last: 'world' }
let { first: f, last: l } = obj
f // 'hello'
l // 'world'
```

- 实际上，对象的解构赋值是下面形式的简写
```js
let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' }
```

- 也就是说，是先找到同名属性，然后再赋值给对应的变量。
```js
let { foo: baz } = { foo: 'aaa', bar: 'bbb' }
baz // aaa
foo // error: foo is not defined
```

#### 嵌套结构的对象

```js
let obj = {
  p: [
    'hello',
    { y: 'World' }
  ]
}
let { p: [x, { y }] } = obj
x // 'Hello'
y // 'World'

// 将p作为变量赋值
let { p, p: [x, { y }] } = obj
x // Hello
y // World
p // [Hello, {y: World}]

// 解构到对象或数组
let obj = {}
let arr = []
// 这个地方必要要有()，避免js将其解释为代码块
({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true })
obj // {prop: 123}
arr // [true]
```

#### 默认值

- 同样：默认值生效的条件是，对象的属性值严格等于undefined

```js
let {x = 3} = {}
let {x: y = 4} = {x: 5} // y: 5
```

#### 对数组进行对象属性的解构

```js
let arr = [1, 2, 3]
let {0: first, [arr.length - 1] : last} = arr
first // 1
last // 3
```

### 字符串

```js
const [a, b, c, d, e] = 'hello'
a // h
b // e
c // l
d // l
e // o

let {length: len} = 'hello'
len // 5
```

### 数值和布尔值

```js
let {toString: s} = 123
s === Number.prototype.toString // true
let {toString: s} = true
s === Boolean.prototype.toString // true

let { prop: x } = undefined // TypeError
let { prop: y } = null // TypeError
```

### 函数参数

```js
function add([x, y]) {
  return x + y
}
add([1, 2]) // 3

function move({x = 0, y = 0} = {}) {
  return [x, y]
}
move({x: 3, y: 8}) // [3, 8]
move({x: 3}) // [3, 0]
move({}) // [0, 0]
move() // [0, 0]
```

### 圆括号

- 尽量不要使用圆括号

- 可以使用圆括号的情况只有一种：赋值语句的非模式部分
```js
[(b)] = [3]
({ p: (d) } = {})
[(parseInt.prop)] = [3]
```

### 用途

- 交换变量的值
```js
let x = 1
let y = 2
[x, y] = [y, x]
```

- 从函数返回多个值
```js
function example() {
  return [1, 2, 3]
}
let [a, b, c] = example()

function exmaple() {
  return {
    foo: 1,
    bar: 2
  }
}
let { foo, bar } = exmaple()
```

- 函数参数的定义
```js
// 参数是一组有次序的值
function f([x, y, z]) {}
f([1, 2, 3])

// 参数是一组无次序的值
function f({x, y, z}) {}
f({z: 3, y: 2, x: 1})
```

- 提取JSON数据
```js
let json = {
  id: 42,
  status: 'ok',
  data: [111, 222]
}
let { id, status, data: numbers } = json
console.log(id, status, numbers)
```

- 函数参数的默认值
```js
function foo(a = 1, b = 2, c = false) {}
```

- 遍历Map解构：任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map解构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便
```js
const map = new Map()
map.set('first', 'hello')
map.set('second', 'world')
for(let [key, value] of map) {
  console.log(key + ' is ' + value)
}
for(let [key] of map) {}
for(let [, value] of map) {}
```

### 输入模块的制定方法
```js
const { a, b } = require('ModuleName')
```

## 字符串的扩展：http://es6.ruanyifeng.com/#docs/string