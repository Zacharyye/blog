---
title: 从浏览器接受URL到开启网络请求线程
order: 2
type: skeleton
---

- [ ] 浏览器什么情况下合并进程
- [ ] [浏览器进程机制整理](https://segmentfault.com/a/1190000012925872)
- [ ] 优化DNS解析
- [ ] 解决tcp/ip并发限制
- [ ] [浏览器内核源码解析](https://www.cnblogs.com/lhb25/p/how-browsers-work.html)
- [ ] 什么是GUI

## 进程和线程
都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同的。

### 背景
CPU + RAM + 各种资源（显卡、光驱、键盘、GPS等）构成了电脑，电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。

### 事实
- CPU太快了，寄存器仅仅能够追的上他的脚步，更别说RAM和别的挂在各总线上的设备了。多个任务要执行在CPU看来就是轮流着来。
- 执行一段程序代码，实现一个功能，当到CPU运行的时候，相关资源（显卡，GPS等）必须就位，然后CPU开始执行。这里除了CPU之外的就构成了程序的执行环境，也就是程序上下文，当程序执行完了或者分配给他的CPU执行时间完了，它就要被切换出去，等待下一次CPU临幸，在被切换出去的最后一步工作就是保存程序当前上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。
- 轮流方法：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B，保存程序B的上下文，以此类推。

### 进程
就是包含上下文切换的程序执行时间总和：CPU加载上下文 + CPU执行时间 + CPU保存上下文

### 线程
进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：程序A得到CPU -> CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的，即线程是：
- 共享了进程的上下文环境的更为细小的CPU时间段

## 多线程的浏览器
浏览器是多进程的，有一个主控进程，以及每一个tab页都会新开一个进程（某些情况下多个tab会合并进程），进程包括：
- 主控进程：负责协调、主控，只有一个
- 插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
- GPU：最多一个，用于3D绘制
- tab页（浏览器内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（优化情况：多个空白tab合并成一个进程）

## 多线程的浏览器内核
每一个tab页可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程：
- GUI渲染线程
- JS引擎线程：内核进程中的一个线程，这也是为什么说JS引擎是单线程的
- 事件触发线程
- 定时触发器线程
- 异步http请求线程

## 多进程优势
- 避免单个tab页影响整个浏览器
- 避免插件影响整个浏览器
- 多进程可以高效的利用多核优势
- 方便使用沙盒模型隔离插件等进程，提高浏览器的稳定性
- 内存等资源消耗更大，有点空间换时间的意思

## 解析URL
输入URL后，会进行解析（URL本质是统一资源定位符），包含：
- protocol：协议头（http、ftp等）
- host：主机域名或IP地址
- port：端口号
- query：查询参数
- fragment：`#`后的hash值，一般用来定位到某个位置

## 网络请求
每次网络请求浏览器内核都需要开辟单独的线程

## 浏览器进程机制

### 大纲
- 区分进程和线程
- 浏览器是多进程的
  - 浏览器都包含哪些进程
  - 浏览器多进程的优势
  - 重点是浏览器内核（渲染进程）
  - Browser进程和浏览器内核（Renderer进程）的通信过程
- 梳理浏览器内核中线程之间的关系
  - GUI渲染线程和js引擎线程互斥
  - JS阻塞页面加载
  - WebWorker，js的多线程
  - WebWorker和SharedWorker
- 简单梳理下浏览器渲染流程
  - load事件和DOMContentLoaded事件的先后
  - css加载是否会阻塞dom树渲染
  - 普通图层和复合图层
- 从Event Loop谈js的运行机制
  - 事件循环机制进一步补充
  - 单独说说定时器
  - setTimeout而不是setInterval
- 事件循环进阶：macrotask和microtask
- 总结

### 区分线程和进程

#### 比喻
- 进程是一个工厂，工厂有它的独立资源
- 工厂之间相互独立
- 线程是工厂中的工人，多个工人协作完成任务
- 工厂内有一个或多个工人
- 工人之间共享空间

解释：
- 工厂的资源：系统分配的内存，独立的一块内存
- 工厂之间的相互独立：进程之间相互独立
- 多个工人协作完成任务：多个线程在进程中协作完成任务
- 工厂内有一个或多个工人：一个进程由一个或多个线程组成
- 工人之间共享空间：同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）

**进程是cpu资源分配的最小单位（系统会给它分配内存）**

术语：
- 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
- 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
- 不同进程之间也可以通信，不过代价较大
- 单线程和多线程都是指在一个进程内的单和多。（属于一个进程）

### 浏览器是多线程的

- 浏览器是多进程的
- 浏览器之所以能运行，是因为系统给它的进程分配了资源（cpu、内存）
- 每打开一个tab页，就相当于创建了一个独立的浏览器进程（有优化机制，有时候多个tab标签会被合并）

#### 浏览器包含哪些进程

- Browser进程：浏览器负责协调、主控的主进程，只有一个。作用：
  - 负责浏览器界面显示，与用户交互。如前进、后退等
  - 负责各个页面的管理，创建和销毁其他进程
  - 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
  - 网络资源的管理、下载等
- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才被创建
- GPU进程：最多一个，用于3D绘制等
- 浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页都是一个进程，互不影响。只要作用为：
  - 页面渲染，脚本执行，事件处理等

#### 浏览器内核

浏览器的渲染进程是多线程的，常驻线程：
- GUI渲染线程
  - 负责渲染浏览器界面，解析HTML、CSS，构建DOM树和RenderObject树，布局和绘制等
  - 当界面需要重绘或由于某种操作引发回流时，该线程就会执行
  - GUI渲染线程和js引擎线程是互斥的，当js引擎执行时GUI线程就被挂起（冻结），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行
- JS引擎线程（js内核）
  - 负责处理js脚本程序（例如V8引擎）
  - 负责解析js脚本，运行代码
  - 一直等待任务队列中任务的到来，然后加以处理，一个tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
  - GUI渲染进程和JS引擎进程是互斥的，如果JS执行的时间过长，就会造成页面的渲染不连贯，导致页面渲染加载阻塞
- 事件触发线程
  - 归属于浏览器而不是JS引擎，用来控制事件循环（相当于浏览器协助JS引擎）
  - 当JS引擎执行代码块如setTimeOut时（也可以来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等），会将对应任务添加到事件进程中
  - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
  - 由于JS单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）
- 定时触发器线程
  - setInterval和setTimeout所在线程
  - 浏览器定时计数器并不是js引擎计数的，因为js引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确性
  - 计时完毕后，添加到事件队列中，等待js引擎空闲后执行
  - W3C在HTML标准中规定，要求setTimeout低于4ms的时间间隔算为4ms
- 异步http请求线程
  - XMLHttpRequest在连接后通过浏览器新开一个线程请求
  - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由js引擎执行

![js_prograss](../../images/js_prograss.png)

为什么js引擎是单线程的，这个问题没有标准答案，可能仅仅是因为多线程的复杂性（加锁等）。

#### Browser进程和浏览器内核（Renderer进程）的通信过程

- Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络资源下载），随后将该任务通过RendererHost接口传递给Render进程
- Renderer进程的Renderer接口收到消息，简单解释后，交给渲染进程，然后开始渲染
  - 渲染进程收到请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染
  - 可能会有JS线程操作DOM（回流、重绘）
  - 最后Render进程将结果传递给Browser进程
- Browser进程接收到结果并将结果绘制出来

### 梳理浏览器内核中线程之间的关系