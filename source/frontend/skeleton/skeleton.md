---
title: 前端骨架
order: 1
type: skeleton
---

## 浏览器从接受链接到渲染整个页面的流程
> [这个比较好，整理出来](https://dailc.github.io/2018/03/12/whenyouenteraurl.html)
> [更详细，涉及硬件层面的，不太适合前端](http://fex.baidu.com/blog/2014/05/what-happen/)

## 大纲
- 从浏览器接受URL到开启网络请求线程
    - 多进程的浏览器
    - 多线程的浏览器内核
    - 解析URL
    - 网络请求都是单独的线程

- 开启网络线程到发出一个完整的http请求
    - DNS查询得到IP
    - TCP/IP请求
    - 五层因特网协议栈
  
- 从服务器接收到请求到对应后台接受到请求
    - 负载均衡
    - 后台处理

- 后台和前台的http交互
    - http报文结构
    - cookie及优化
    - gzip压缩
    - 长连接和短连接
    - http2.0
    - https

- 单独拎出来的缓存问题，http的缓存
    - 强缓存和弱缓存
    - 缓存头部简述
    - 头部的区别

- 解析页面流程
    - 流程简述
    - HTML解析，构建DOM
    - 生成CSS规则
    - 构建渲染树
    - 渲染
    - 简单层和复合层
    - Chrome中的调试
    - 资源外链的下载
    - loaded和domcontentloaded

- CSS可视化格式模型
    - 包含块
    - 控制框
    - BFC
    - IFC

- JS引擎解析过程
    - 解释阶段
    - 预处理阶段
    - 执行阶段
    - 回收机制

## 前端向知识重点
- 核心知识：浏览器模型、渲染原理、JS解析过程、JS运行机制，作为骨架承载知识体系
- 重点知识：http、web、跨域、算法
- 扩展知识：五层因特网协议栈、hybrid模式、移动原生开发、后台相关

## 从浏览器接受URL到开启网络请求线程

- [ ] 浏览器什么情况下合并进程
- [ ] [浏览器进程机制整理]((https://segmentfault.com/a/1190000012925872))
- [ ] 优化DNS解析
- [ ] 解决tcp/ip并发限制

### 进程和线程
都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同的。

#### 背景
CPU + RAM + 各种资源（显卡、光驱、键盘、GPS等）构成了电脑，电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。

#### 事实
- CPU太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是望其项背。多个任务要执行在CPU看来就是轮流着来。
- 执行一段程序代码，实现一个功能，当到CPU运行的时候，相关资源（显卡，GPS等）必须就位，然后CPU开始执行。这里除了CPU之外的就构成了程序的执行环境，也就是程序上下文，当程序执行完了或者分配给他的CPU执行时间完了，它就要被切换出去，等待下一次CPU临幸，在被切换出去的最后一步工作就是保存程序当前上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。
- 轮流方法：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B，保存程序B的上下文，以此类推。

#### 进程
就是包含上下文切换的程序执行时间总和：CPU加载上下文 + CPU执行时间 + CPU保存上下文

#### 线程
进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：程序A得到CPU -> CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的，即线程是：
- 共享了进程的上下文环境的更为细小的CPU时间段

### 多线程的浏览器
浏览器是多进程的，有一个主控进程，以及每一个tab页都会新开一个进程（某些情况下多个tab会合并进程），进程包括：
- 主控进程：负责协调、主控，只有一个
- 插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
- GPU：最多一个，用于3D绘制
- tab页（浏览器内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（优化情况：多个空白tab合并成一个进程）

### 多线程的浏览器内核
每一个tab页可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程：
- GUI渲染线程
- JS引擎线程：内核进程中的一个线程，这也是为什么说JS引擎是单线程的
- 事件触发线程
- 定时触发器线程
- 异步http请求线程

### 多线程优势
- 避免单个tab页影响整个浏览器
- 避免插件影响整个浏览器
- 多进程可以高效的利用多核优势
- 方便使用沙盒模型隔离插件等进程，提高浏览器的稳定性

### 解析URL
输入URL后，会进行解析（URL本质是统一资源定位符），包含：
- protocol：协议头（http、ftp等）
- host：主机域名或IP地址
- port：端口号
- query：查询参数
- fragment：`#`后的hash值，一般用来定位到某个位置

### 网络请求
每次网络请求浏览器内核都需要开辟单独的线程

### 浏览器进程机制
todo

## 开启网络线程到发出一个完整的http请求

### DNS查询得到IP
如果输入的是域名，需要进行dns解析成IP，大致流程：
- 如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，在没有使用host
- 如果本地没有，向dns域名服务器查询（可能经过路由，路由也有缓存），查询到对应的IP

注意：
- 域名查询有可能经过了CDN调度器的（如果有CDN存储功能的话）
- DNS解析是很耗时的，如果解析域名过多，会让首屏加载变得过慢，可以考虑`dns-prefetch`优化

### TCP/IP请求
- http本质就是TCP/IP请求
- 建立连接：三次握手，抽象为：
  ```
  客户端：hello，你是sever么？
  服务端：hello，我是server，你是client么？
  客户端：yes，我是client！
  ```
- 断开连接：四次挥手，抽象为：
  ```
  主动方：我已经关闭了向你那边的主动通道了，只能被动接收了
  被动方：收到通道关闭的信息
  被动方：那我也告诉你，我这边向你的主动通道也关闭了
  主动方：最后收到数据，之后双方无法通信
  ```
- TCP将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输
- 并发限制
  - 浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）
  - http1.0中往往一个资源下载就需要对应一个tcp/ip请求

- get和post区别
  - get产生一个数据包，post两个
    - get请求时，浏览器会把headers和data一起发送出去，服务器响应200（返回数据）
    - post请求时，浏览器先发送headers，服务器响应100 continue，浏览器再发送data，服务器响应200（返回数据）

### 五层因特网协议栈
- 从客户端发出http请求到服务器接受，中间会经过一系列流程
- 完整的OSI七层框架
  - 应用层：DNS解析成IP并发送http请求
  - 表示层（OSI）：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密于解密，数据压缩和终端类型转换等
  - 会话层（OSI）：具体管理不同用户和进程之间的对话，如控制登录和注销过程
  - 传输层：建立tcp连接（三次握手）
  - 网络层：IP寻址
  - 数据链路层：封装成帧
  - 物理层：利用物理介质传输比特流，传输的时候通过双绞线，电磁波等各种介质

## 从服务器接受请求到对应后台接受请求
- [ ] 反向代理

### 负载均衡
对于大型的项目，由于并发访问量很大，所以一台服务器是吃不消的，所以一般会有若干服务器组成一个集群，然后配合反向代理实现负载均衡，简单的说：
用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户。

### 后台处理
一般后台都是部署到容器中的，一般为：
- 容器接收到请求
- 对应容器中的后台程序接收到请求
- 后台程序处理后返回响应结果

概括：
- 一般有的后端是有统一的验证的，如安全拦截，跨域验证
- 如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）
- 然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）
- 等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）
- 然后就是将这个包从后端发送到前端，完成交互

## 后台和前台的http交互
前后端交互时，http报文作为信息的载体

### http报文结构
跨域请求拒绝时，可能的method是options，状态码为：404/405等
部分头部字段一览：

- 通用头部
  - Request Url：请求的web服务器地址
  - Request Method：请求方式（GET、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）
  - Status Code：请求返回的状态码，如200成功
  - Remote Address：请求的远程服务器地址（会转为IP）
  - Referrer-Policy：用来监管哪些访问来源信息，no-referrer-when-downgrade （默认值）在没有指定任何策略的情况下用户代理的默认行为。在同等安全级别的情况下，引用页面的地址会被发送(HTTPS->HTTPS)，但是在降级的情况下不会被发送 (HTTPS->HTTP)

- 请求头部
  - Accept: 接收类型，表示浏览器支持的MIME类型（对标服务端返回的Content-Type）
  - Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收
  - Content-Type：客户端发送出去实体内容的类型
  - Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache
  - If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中
  - Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间
  - Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中
  - If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中
  - Cookie: 有cookie并且同域访问时会自动带上
  - Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive
  - Host：请求的服务器URL
  - Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私
  - Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)
  - User-Agent：用户客户端的一些必要信息，如UA头部等

- 响应头部
  - Access-Control-Allow-Headers: 服务器端允许的请求Headers
  - Access-Control-Allow-Methods: 服务器端允许的请求方法
  - Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）
  - Content-Type：服务端返回的实体内容的类型
  - Date：数据从服务器发送的时间
  - Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档
  - Last-Modified：请求资源的最后修改时间
  - Expires：应该在什么时候认为文档已经过期,从而不再缓存它
  - Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效
  - ETag：请求变量的实体标签的当前值
  - Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端
  - Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）
  - Server：服务器的一些相关信息

一般来说，请求头部和响应头部是匹配分析的：

请求头部 | 响应头部
--- | ---
Accept | Content-Type
Origin | Access-Control-Allow-Origin
If-Modified-Since | Last-Modified
If-None-Match | ETag

- 请求/响应实体
  - 除了头部，还有消息实体
  - 请求实体会将一些需要的参数都放入进去（用于POST请求）
  - 可以放参数的序列化形式（a=1&b=2这种），或者直接放表单对象（Form data）
  - 而一般响应实体中，就是放服务端需要传给客户端的内容
  - 一般现在的接口请求时，实体中就是对于信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染

- CRLF
  - 回车换行，一般用作分隔符存在
  - 请求头部和实体消息之间有一个CRLF分隔，响应头部和响应实体之间用一个CRLF分隔


### cookie及优化
是一种浏览器本地存储方式，一般用来帮助客户端和服务端通信，常用来进行身份校验，结合服务端的session使用。
场景：
- 在登录页面，用户登录了
- 此时，服务端会生成一个session，session中有对于用户的信息（用户名，密码等）
- 然后会有一个sessionid（相当于服务端这个session对应的key）
- 服务端在登录页面写入cookie，值就是：jsessionid=xxx
- 浏览器本地就有这个cookie了，以后访问相同域名下的页面时，自动带上cookie，自动校验，在有效时间内无需二次登陆

一般来说，cookie是不允许存放敏感信息的（禁止明文储存用户名、密码），因为非常不安全，如果一定要储存，设置cookie为httponly，考虑rsa等非对称加密

- 针对同域名下大量不需要携带cookie请求（如对静态资源的访问）的优化
  - 将静态资源分组，分别放到不同的域名下

- 在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上pc）
  - 此时就需要用到一种优化方案：dns-prefetch（让浏览器空闲时提前解析dns域名，不过也请合理使用，勿滥用）

![cookie交互](../../images/http_cookie_session.png)

### gzip压缩

> [gzip探秘](https://segmentfault.com/a/1190000012800222)

- 首先，明确gzip是一种压缩格式，需要浏览器支持才有效（不过一般现在浏览器都支持）， 而且gzip压缩效率很好（高达70%左右）
- 然后gzip一般是由apache、tomcat等web服务器开启
- 当然服务器除了gzip外，也还会有其它压缩格式（如deflate，没有gzip高效，且不流行）
- 所以一般只需要在服务器上开启了gzip压缩，然后之后的请求就都是基于gzip压缩格式的， 非常方便。
- 解压的角色一般是浏览器，这样就可以减短请求时间了

### 长连接和短连接

tcp/ip层面：
- 长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心态包）
- 短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接

http层面：
- http1.0：默认使用的是短连接，浏览器每进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接
- http1.1：默认使用长连接，使用长连接会有：connection：keep-alive，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接

注意：keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置，另外长连接需要客户端和服务器都支持才有效

### http2.0
http2.0不是https，相当于下一代规范，https的请求可以是http2.0规范的，http2.0和http1.1显著不同点：
- 1.1中，每请求一个资源，都需要开启一个tcp/ip连接，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著满了下来
- 2.0中，一个tcp/ip请求可以请求多个资源，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升
- 2.0特性
  - 多路复用：一个tcp/ip连接可以请求多个资源
  - 首部压缩：http头部压缩，减少体积
  - 二进制分帧：在应用层和传输层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量
  - 服务器推送：服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端
  - 请求优先级：如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求

### https
- 安全版本的http
- 和http区别：在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析
- https升级：后端需要申请证书等，开销比http大（需要额外建立安全链接以及加密等），所以一般来说http2.0配合https体验更佳（http2.0更快了）
- SSL/TLS握手流程，按顺序：
  - 浏览器请求建立SSL链接，并向服务端发送一个随机数（Client random）和客户端支持的加密算法，此时是明文传输
  - 服务端从中选出一组加密算法和hash算法，回复一个随机数（Server random），并将自己的身份信息以证书的形式返回给浏览器（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）
  - 浏览器收到服务端的证书后
    - 验证证书的合法性：颁发机构是否合法，证书中包含的网址是否和正在访问的一样，如果证书信任，则浏览器会显示一个小锁头，否则会有提示
    - 用户接受证书后（不管信不信任），浏览会生产新的随机数（Premaster secret），然后证书中的公钥以及指定的加密方法加密Premaster secret，发送给服务器。
    - 利用Client random、Server random、Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-session key
    - 使用约定好的HASH算法计算握手信息，并使用生成的`session key`对消息进行加密，最后将之前生成的所有信息发送给服务端。
  - 服务端收到浏览器的回复
    - 利用已知的加解密方式与自己的私钥进行解密，获取Premaster secret
    - 和浏览器相同规则生成`session key`
    - 使用`session key`解密浏览器发来的握手信息，并验证hash是否和浏览器发来的一致
    - 使用`session key`加密一段握手信息，发送给浏览器
  - 浏览器解密并计算握手消息的hash，如果与服务端发来的hash一致，此时握手过程结束
  - 之后的所有https通信数据将由之前浏览器生成的session key并利用对称加密算法进行加密

## 单独拎出来的http缓存问题
前后端的http交互中，使用缓存能很大程度上提升效率，而且基本上对性能有要求的前端项目都是必用缓存的

### 强缓存和弱缓存
- 强缓存（200 from cache）：浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求
  - 未过期时，必须更新资源路径才能发起新的请求
- 协商缓存（304）：浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存
  - 使用Ctrl + F5强制刷新可以使得协商缓存无效

### 缓存头部
- 强缓存：
  - http1.1：Cache-Control/Max-Age
  - http1.0：Pragma/Expires
- 协商缓存
  - http1.1：If-None-Match/E-tag
  - http1.0：If-Modified-Since/Last-Modified

### 头部区别

http1.0中的缓存控制：

- Pragma：严格来说，它不属于专门的缓存控制头部，但是它设置no-cache时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）
- Expires：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如Expires：Fri, 30 Oct 1998 14:19:41
- If-Modified-Since/Last-Modified：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-Modified-Since，而服务端的是Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到1s以内

http1.1中的缓存控制：

- Cache-Control：缓存控制头部，有no-cache、max-age等多种取值
- Max-Age：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算
- If-None-Match/E-tag：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-None-Match，而服务端的是E-tag，同样，发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。

Max-Age相比Expires：
Expires使用的是服务器端的时间
但是有时候会有这样一种情况-客户端时间和服务端不同步
那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期
所以一般http1.1后不推荐使用Expires
而Max-Age使用的是客户端本地时间的计算，因此不会有这个问题
因此推荐使用Max-Age。
注意，如果同时启用了Cache-Control与Expires，Cache-Control优先级高。

E-tag相比Last-Modified：

Last-Modified：
表明服务端的文件最后何时改变的
它有一个缺陷就是只能精确到1s，
然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效

E-tag：
是一种指纹机制，代表文件相关指纹
只有文件变才会变，也只要文件变就会变，
也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了
如果同时带有E-tag和Last-Modified，服务端会优先检查E-tag

各大缓存头部的整体关系如下图：
![http_cache](../../images/http_cache.png)

## 解析页面流程

### 简述
- 解析HTML，构建DOM树
- 解析CSS，生成CSS规则树
- 合并DOM树和CSS规则，生成render树
- 布局render树（layout/reflow），负责各元素尺寸、位置的计算
- 绘制render树（paint），绘制页面像素信息
- 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上

如下图：
![browser_rending](../../images/browser_rending.png)

### HTML解析，构建DOM
- 浏览器解析HTML，构建DOM树
- 解析过程：Bytes -> characters -> tokens -> nodes -> DOM

实例，假设有这样一个HTML页面：
```html
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link href="style.css" rel="stylesheet">
    <title>Critical Path</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg"></div>
  </body>
</html>
```
浏览器处理如下：
![browser_parse_html](../../images/browser_parse_html.png)

重点过程：
- Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符
- Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token，每个token都有自己独特的含义以及规则集
- Lexing词法分析：分词的结果是得到一堆的token，此时把它们转换为对象，这些对象分别定义它们的属性和规则
- DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样，例如：body对象的父节点就是HTML对象，然后段落p对象的父节点就是body对象

### 生成CSS规则
简述为：Bytes -> characters -> tokens -> nodes -> CSSOM

实例，有这样一个css文件：
```css
body { font-size: 16px }
p { font-weight: bold }
span { color: red }
p span { display: none }
img { float: right }
```
最终的CSSOM树就是：
![browser_parse_cssom](../../images/browser_parse_cssom.png)

### 构建渲染树
- 当DOM树和CSSOM都有了后，就要开始构建渲染树了
- 一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应
- 有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者display: none等
- 示意图：
![browser_parse_rendertree](../../images/browser_parse_rendertree.png)

### 渲染
有了render树，接下来就是开始渲染了，基本流程如下：
![browser_rendingprocess](../../images/browser_rendingprocess.png)
简述：
- 计算CSS样式
- 构建渲染树
- 布局，主要定位坐标和大小，是否换行，各种position、overflow、z-index属性
- 绘制，将图像绘制出来

图中的线和箭头代表通过js动态修改了DOM或CSS，导致了回流或重绘

- 回流：一般意味着元素的内容、结果、位置和尺寸发生了变化，需要重新计算样式和渲染树
- 重绘：意味着元素发生的改变只是影响了元素的一些外观之类的时候（背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了

### 回流
回流的成本开销要高于重绘，而且一个节点的回流往往会导致子节点以及同级节点的回流，所以优化方案中一般都包括：尽量避免回流

#### 什么会引起回流
- 页面渲染初始化
- DOM结构改变：删除了某个节点
- render树变化：减少了padding
- 窗口resize
- 改变字体大小
- 获取某些属性，引发：
  - 很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括：
    - offset(Top/Left/Width/Height)
    - scroll(Top/Left/Width/Height)
    - cilent(Top/Left/Width/Height)
    - width,height
    - 调用了getComputedStyle()或者IE的currentStyle

#### 优化方案
回流一定伴随着重绘，重绘却可以单独出现
- 减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新
- 避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document中，也就是离线操作
- 避免多次调用触发浏览器回流的属性，如果需要，应该使用变量缓存
- 将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高

#### 示例
```js
var s = document.body.style;
s.padding = "2px"; // 回流 + 重绘
s.border = "1px solid red"; // 再一次 回流 + 重绘
s.color = "blue"; // 再一次重绘
s.backgroundColor = "#ccc"; // 再一次 重绘
s.fontSize = "14px"; // 再一次 回流 + 重绘
document.body.appendChild(document.createTextNode('abc!')); // 添加node，再一次 回流 + 重绘
```

### 简单层和复合层
上述中的渲染止步于绘制，但实际上绘制这一步就没有这么简单，它可以结合复合层和简单层的概念来讲。
简述：
- 默认只有一个复合图层，所有的DOM节点都是在这个复合图层下的
- 如果开启了硬件加速功能，可以将某个节点变成复合图层
- 复合图层之间的绘制互不干扰，由GPU直接控制
- 简单图层中，就算是absolute等布局，变化时不影响整体的回流，但由于在同一个图层中，仍然是会影响绘制的，因此做动画时性能仍然很低。而复合层是独立的，所以一般做动画推荐使用硬件加速

### Chrome中的调试
Chrome的开发者工具中，Performance中可以看到详细的渲染过程

### 资源外链的下载
在解析html时，会遇到一些资源外链，此时就需要进行单独处理了

#### 分类
- CSS样式资源
- JS脚本资源
- img图片类资源

#### 遇到外链时的处理
当遇到上述的外链时，会单独开启一个下载线程去下载资源（http1.1中是每个资源的下载都要开启一个http请求，对应一个tcp/ip链接）

#### 遇到CSS样式资源
- CSS下载时异步，不会阻塞浏览器构建DOM树
- 会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行，这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建
- 有例外，media query声明的CSS是不会阻塞渲染的

#### 遇到JS脚本资源
- 阻塞浏览器的解析，发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML
- 浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（有并发上限），虽然脚本可以并行下载，但解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已
- defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行
  - defer是延迟执行：在浏览器看起来的效果像是将脚本放在了body后面一样（虽然按规范应该是在DOMContentLoaded事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）
  - async是异步执行：异步下载完毕后就会执行，不确保执行顺序，一定在onload前，但不确定在DOMContentLoaded事件的前或后

#### 遇到图片类资源
遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方

#### loaded和domcontentloaded
- DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)
- load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了

## CSS的可视化格式模型

- [ ] 各种定位相对与什么元素
- [ ] [其它](http://bbs.csdn.net/topics/340204423)

**规定了浏览器在页面中如何处理文档数**

- CSS中规定每一个元素都有自己的盒子模型（相当于规定了这个元素如何显示）
- 可视化格式模型就是把这些盒子按照规则摆放到页面上，也就是如何布局
- 盒子模型规定了怎么在页面里摆放盒子，盒子的相互作用等

**CSS有三种定位机制：普通流，浮动，绝对定位，如无特别提及，下文中都是针对普通流中的**

### 包含块
一个元素的box定位和尺寸，会与某一矩形框有关，这个框称之为包含块。
元素会为它的子孙元素创建包含块，但是，并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系。
- 根元素是最顶端的元素，它没有父节点，包含块就是初始包含块
- static和relative的包含块由它最近的块级、单元格或者行内祖先元素的内容框创建
- fixed的包含块是当前可视窗口
- absolute的包含块由它最近的position属性为absolute、relative或fixed的祖先元素创建
  - 如果祖先元素是行内元素，则包含块取决于其祖先元素的direction特性
  - 如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界

### 控制框

- 块框
  - 块级元素会生成一个块框，块框会占据一整行，用来包含子box和生成的内容
  - 块框同时也是一个块包含框，里面要么只包含块框，要么只包含行内框，如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围

**如果一个块框在其中包含另外一个块框，那么我们强迫它只能包含块框，因此其它文本内容生成出来的都是匿名块框（而不是匿名行内框）**

- 行内框
  - 一个行内元素生成一个行内框
  - 行内元素能排在一行，允许左右有其它元素

- display属性的影响
  - block：元素生成一个块框
  - inline：元素生成一个或多个的行内框
  - inline-block：元素产生一个行内级块框，行内块框的内部会被当作块框来格式化，而此元素本身会被当作行内级框来格式化（这也是为什么会产生BFC）
  - none：不生成框，不在格式化结构中，visibility：hidden则会产生一个不可见的框

- 总结
  - 如果一个框里，有一个块级元素，那么这个框里的内容都会被当作块框来进行格式化，因为只要出现了块级元素，就会将里面的内容分成几块，每一块独占一行（出现行内可以用匿名块框解决）
  - 如果一个框里，没有任何块级元素，那么这个框里的内容会被当成行内框来格式化，因为里面的内容会被当成行内框来格式化，因为里面的内容是按照顺序成行的排列

### BFC
全称：Block Formatting Context

- 定义框内部的元素渲染规则
  - FC像是一个大箱子，里面装有很多元素
  - 箱子可以隔开里面的元素和外面的元素（所以外部并不会影响FC内部的渲染）
  - 内部的规则可以是：如何定位，宽高计算，margin折叠等等

- 不同类型的框参与的FC类型不同，譬如块级框对应BFC，行内框对应IFC：并不是说所有框都会产生FC，而是符合特定条件才会产生，只有产生了对应的FC后才会应用对应的渲染规则，规则：
  - 在块格式化上下文中
  - 每一个元素左外边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边），即使存在浮动也是如此（所以浮动元素正常会直接贴近它的包含块的左边，与普通元素重合），除非这个元素也创建了一个新的BFC

- 特点
  - 内部box在垂直方向，一个接一个的放置
  - box的垂直方向由margin决定，属于同一个BFC的两个box间的margin会重叠
  - BFC区域不会与float box重叠（可用于排版）
  - BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此
  - 计算BFC的高度时，浮动元素也参与计算（不会浮动塌陷）

- 如何触发BFC
  - 根元素
  - float属性不为none
  - position为absolute或fixed
  - display为inline-block, flex, inline-flex，table，table-cell，table-caption
  - overflow不为visible

### IFC

- 规则
  - 在行内格式化上下文中
  - 框一个接一个地水平排列，起点是包含块的顶部
  - 水平方向上的 margin，border 和 padding 在框之间得到保留
  - 框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐

- 行框
  - 包含那些框的长方形区域，会形成一行，叫做行框：行框的宽度由它的包含块和其中的浮动元素决定，高度的确定由行高度计算规则决定
  - 规则：
    - 如果几个行内框在水平方向无法放入一个行框内，它们可以分配在两个或多个垂直堆叠的行框中（即行内框的分割）
    - 行框在堆叠时没有垂直方向上的分割且永不重叠
    - 行框的高度总是足够容纳所包含的所有框。不过，它可能高于它包含的最高的框（例如，框对齐会引起基线对齐）
    - 行框的左边接触到其包含块的左边，右边接触到其包含块的右边。
    浮动元素可能会处于包含块边缘和行框边缘之间
    - 尽管在相同的行内格式化上下文中的行框通常拥有相同的宽度（包含块的宽度），它们可能会因浮动元素缩短了可用宽度，而在宽度上发生变化
    - 同一行内格式化上下文中的行框通常高度不一样（如，一行包含了一个高的图形，而其它行只包含文本）
    - 当一行中行内框宽度的总和小于包含它们的行框的宽，它们在水平方向上的对齐，取决于 `text-align` 特性
    - 空的行内框应该被忽略
    - 即不包含文本，保留空白符，margin/padding/border非0的行内元素，以及其他常规流中的内容(比如，图片，inline blocks 和 inline tables)，并且不是以换行结束的行框，必须被当作零高度行框对待

- 总结
  - 行内元素总是会应用IFC渲染规则
  - 行内元素会应用IFC规则渲染，譬如text-align可以用来居中
  - 块框内部，对于文本这类的匿名元素，会产生匿名行框包围，而行框内部就应用IFC渲染规则
  - 行内框内部，对于那些行内元素，一样应用IFC渲染规则
  - 另外，inline-block，会在元素外层产生IFC（所以这个元素是可以通过text-align水平居中的），当然，它内部则按照BFC规则渲染

- 其它
  - 常规流，浮动，绝对定位等区别
  - 浮动元素不包含在常规流中
  - 相对定位，绝对定位，Fixed定位等区别
  - z-index的分层显示机制等

## JS引擎解析过程

- [ ] js是如何操纵dom树的

### 解释阶段
**JS是解释型语言，所以它无需提前编译，而是由解释器实时运行。**
简述如下：
1. 读取代码，进行词法分析，然后将代码分解成词元（token）
1. 对词元进行语法分析，然后将代码整理成语法树
1. 使用翻译器，将代码转为字节码
1. 使用字节码解释器，将字节码转为机器码

最终浏览器执行的就是机器码
- 为了提高运行速度，现代浏览器一般采用即使编译：即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存，这样整个程序的运行速度都能得到显著提升。
- 不同浏览器策略可能还不同，有的浏览器就省略了字节码的翻译步骤，直接转为机器码（chromeV8）

总结：**核心的JIT编译器将源码编译成机器码运行。**

### 预处理阶段
正式执行JS前，还会有一个预处理阶段（变量提升，分号补全），这个阶段会做一些事情来确保JS可以正确执行：

- 分号补全：
  - 当有换行符，包括含有换行符的多行注释，并且下一个token没法跟前面的语法匹配时，会自动补分号
  - 当有`}`时，如果缺少分号，会补分号
  - 程序源代码结束时，如果缺少分号，会补分号

- 变量提升
  - 包括函数提升和变量提升，函数优先，如果函数名和变量名相同，还是函数优先，不管声明顺序

### 执行阶段
- 执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）
  - 浏览器首次载入脚本，创建全局执行上下文，并压入执行栈栈顶，不可被弹出
  - 每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部
  - 一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给剩下的堆栈
  - 依次执行，最终都会回到全局执行上下文
- VO（变量对象）和AO（活动对象）
  - VO是执行上下文的属性，只有全局上下文的变量对象允许通过VO的属性名称来间接访问（因为在全局上下文里，全局对象自身就是变量对象）
  - 当函数被调用者激活，AO就创建了
  - 在函数上下文中：VO === AO
  - 在全局上下文中：VO === this === global
  - 总的来说，VO中会存放一些变量信息（如声明的变量，函数，arguments参数等等）
- 作用域链
  - 在函数上下文中，查找一个变量foo，如果函数的VO中找到了，就直接使用，否则去它的父级作用域链中（__parent__）找，如果父级中没找到，继续往上找，直到全局上下文中也没找到就报错
- this机制
  - this是执行上下文环境的一个属性，而不是某个变量对象的属性
  - this是没有一个类似搜寻变量的过程
  - 当代码中使用了this，这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻
  - this的值只取决中进入上下文时的情况

### 回收机制
JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。

一般来说，垃圾处理器有自己的回收策略。

譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）

常用的两种垃圾回收规则是：
- 标记清除：js用的
  - 遍历所有可访问的对象
  - 回收已不可访问的对象
  - 当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。
  - 从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。
  - 而当变量离开环境时，则将其标记为“离开环境”。
  - 垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。
  - 然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。
  - 而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。
  - 最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。
- 引用计数
  - 跟踪记录每个值被引用的次数，当一个值被引用时，次数+1，减持时-1，下次垃圾回收器会回收次数为0的值的内存（当然了，容易出循环引用的bug）

#### GC的缺陷
和其他语言一样，javascript的GC策略也无法避免一个问题： GC时，停止响应其他操作
这是为了安全考虑。
而Javascript的GC在100ms甚至以上
对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。
这就是引擎需要优化的点： 避免GC造成的长时间停止响应。
GC优化策略
这里介绍常用到的：分代回收（Generation GC）
目的是通过区分“临时”与“持久”对象:
- 多回收“临时对象”区（young generation）
- 少回收“持久对象”区（tenured generation）
- 减少每次需遍历的对象，从而减少每次GC的耗时。