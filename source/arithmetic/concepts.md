---
title: 概念
order: 2
type: arithmetic
---

## 复杂度

### 时间复杂度
- O(1)：相当于哈希表，js中类似直接从一个对象中使用键取出某个值，例子：周围有一堆柜子，柜子上标记着柜子里是什么，现在你可以直接根据标记去取某个东西，耗费的时间是一样的
- O(n)：相当于遍历一次从某个数组中拿到最大值，随着数组长度的增加耗费的时间也会线性增大，例子：从一堆试卷中找出最高分，首先你把当前最高分拿出来，如果出现更高分，替换它
- O(n^2)：比较挫的一些排序，如冒泡、选择等，例子：首先从一堆试卷中找出最高分，最高分试卷放在一边，再从剩下的试卷中找出最高分，找出后放在已经找出的最高分试卷上面，这样的操作需要执行O(n)次，每次的复杂度是O(n)，故复杂度是O(n^2)，最后得到分数从高到低的试卷堆
- O(logn)：的算法复杂度，典型的比如二分查找。设想一堆试卷，已经从高到底按照分数排列了，我们现在想找到有没有59分的试卷。怎么办呢？先翻到中间，把试卷堆由中间分成上下两堆，看中间这份是大于还是小于59，如果大于，就留下上面那堆，别的丢掉，如果小于，就留下下面那堆，丢掉上面。然后按照同样的方法，每次丢一半的试卷，直到丢无可丢为止。例子：假如有32份试卷，你丢一次，还剩16份 ，丢两次，还剩下8 份，丢三次，就只剩下4份了，可以这么一直丢下去，丢到第五次，就只剩下一份了。而log_2(32)=5，理解了这一点，就理解了为什么快速排序是O(logn)了

### 空间复杂度
- 一个算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。
- 一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。
- 一个算法的空间复杂度只考虑在运行过程中为局部变量分配的存储空间的大小，它包括为参数表中形参变量分配的存储空间和为在函数体中定义的局部变量分配的存储空间两个部分。
- 算法的空间复杂度一般也以数量级的形式给出。如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n)；当一个算法的空间复杂度与n成线性比例关系时，可表示为O(n)。若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。

## 排序

### 稳定性
就是如果两个两个值相等，排序后他们的位置顺序应该跟排序前是一致的，否则，就不稳定

### 计算复杂度（最差、平均、和最好表现）
依据串行（list）的大小（n），一般而言，好的表现是O(nlogn)，且坏的行为是O(n2)。对于一个排序理想的表现是O(n)。仅使用一个抽象关键比较运算的排序算法总平均上总是至少需要O(nlogn)。
所有基于比较的排序的时间复杂度至少是 O(nlogn)。

### 常见的排序算法

常见的稳定排序算法有：
- 冒泡排序（Bubble Sort） — O(n²)
- 选择排序 - O(n²)
- 插入排序（Insertion Sort）— O(n²)
- 桶排序（Bucket Sort）— O(n); 需要 O(k) 额外空间
- 计数排序 (Counting Sort) — O(n+k); 需要 O(n+k) 额外空间
- 合并排序（Merge Sort）— O(nlogn); 需要 O(n) 额外空间
- 二叉排序树排序 （Binary tree sort） — O(n log n) 期望时间; O(n²)最坏时间; 需要 O(n) 额外空间
- 基数排序（Radix sort）— O(n·k); 需要 O(n) 额外空间

常见的不稳定排序算法有：
- 选择排序（Selection Sort）— O(n²)
- 希尔排序（Shell Sort）— O(nlogn)
- 堆排序（Heapsort）— O(nlogn)
- 快速排序（Quicksort）— O(nlogn) 期望时间, O(n²) 最坏情况; 对于大的、乱数串行一般相信是最快的已知排序

### 冒泡排序
速度很慢，不推荐使用
思路：一个数组需要降序排列，首先对比`a[0]`和`a[1]`，如果`a[0] < a[1]`，交换值，否则继续比较`a[1]`和`a[2]`，以此类推
```js
function bubbleSort(nums) {
  // 降序
  // 外层循环一共需要nums.length次比较，每次比较产生一个排序好的元素
  // 内层循环一共需要nums.length - i次比较，除去已经排好的元素，对剩下的元素进行排序
  // 最终得到升序/降序的数组
  for(let i = 0; i < nums.length; i++) {
    for(let j = 0; j < nums.length - i; j++) {
      if(nums[j - 1] > nums[j]) {
        const temp = nums[j - 1]
        nums[j - 1] = nums[j]
        nums[j] = temp
      }
    }
  }
  return nums
}
```

### 选择排序
速度很慢，不推荐使用
思路：冒泡排序的优化版，只有确定顺序后才进行调换
```js
function chooseSort(nums) {
  for(let i = 0; i < nums.length; i++) {
    for(let j = i; j < nums.length; j++) {
      if(nums[i] < nums[j]) {
        const temp = nums[i]
        nums[i] = nums[j]
        nums[j] = temp
      }
    }
  }
  return nums
}
```

### 插入排序
```js
function InsertSort(array, direction) {
  for(let i = 1; i < array.length; i++) {
    let flag = array[i]
    let j = i - 1
    const condition = direction ? flag < array[j] : flag > array[j]
    while(j >= 0 && condition) {
      array[j + 1] = array[j]
      j--
    }
    array[j + 1] = flag
  }
  return array
}
```

### 快速排序

> [参考资料](http://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html)

> [参考资料](https://github.com/francistao/LearningNotes/blob/master/Part3/Algorithm/Sort/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%2010%20%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.md)

## 遍历

### 二叉树遍历
遍历二叉树的所有结点访问且仅访问一次

### 先（前）序遍历
根节点->左子树->右子树

### 中序遍历
左子树->根节点->右子树

### 后序遍历
左子树->右子树->根节点

### 根据先序、中序推算出后序
首先根据先序、中序推算出整个树形结构，然后根据树形结构推算出后序